Nextjs

✅React의 CSR(Client Side Rendering)
= 유저 -> 브라우저(클라이언트) : 접속 요청
+= 브라우저 -> 서버 : 접속요청
+= 서버 -> 브라우저 : 빈 껍데기 html 응답
+= 브라우저 -> 유저 : 빈 화면 렌더링 (💥아무것도 안 보임)
+= (후속 작업)서버 -> 브라우저 : js Bundle(리액트 앱을 번틀링해서 하나로 묶어서 후속으로 보내줌 : 이 서비스에서 접근 가능한 모든 컴포넌트 코드 존재)
+= (후속 작업)브라우저 -> 유저 : js 실행 후 컨텐츠 렌더링(💥화면에 보임)
- 장점 : 초기 접속 이후의 페이지 이동이 빠름
- 🚨🚨CSR 단점: FCP(초기 접속 속도) 느림(브라우저가 하는일이 많아서)🚨🚨
(그래도 이후 페이지 이동 작업은
브라우저가 자체적으로 이제 서버가 준 리액트앱을 가지고 있으니까 리액트 앱을 실행하기에
페이지 이동은 빨라지는거지)

✅FCP(First Contentful Paint) <= 느려서 좋을게 하나도 없음...(사용자들 이탈이 생김)
- 브라우저가 처음으로 "컨텐츠"를 화면에 렌더링한 시점까지 걸린 시간
- 요청시작 시점으로부터 컨텐츠가 화면에 처음 나타나는데 걸리는 시간( 요청시작 <--> 컨텐츠 렌더링 )
 "컨텐츠"는 텍스트, 이미지(SVG 포함), 캔버스, 비디오 등 사용자가 실제로 볼 수 있는 요소를 의미해.
- 인터렉션(상호작용) 불가한 상태

🔽🔽🔽🔽🔽🔽🔽🔽🔽🔽🔽
💡Nextjs 사용하면
💡FCP(초기 접속 속도) 속도 느린 부분이 낮아짐.
[차이점]
사전에 렌더링된 html을 브라우저에 보낸다. (CSR은 빈 HTML을 보내는 반면에 사전렌더링은 '렌더링 된 HTML'을 보내는 거야)
그대로 화면에 브라우저가 렌더링하고 사용자가 바로 완성된 화면을 볼 수 있다. <=  FCP가 큰 폭으로 단축)

💥2가지 렌더링 헷갈리지?
    ✅JS 실행 = 曰: 렌더링
    - 🚨자바스크립트 코드(React 컴포넌트)를 HTML 페이지로 다 렌더링 시켜줌
        ('리액트 컴포넌트들을 HTML로 변환'하는 과정)
    (웹 서버 ->  브라우저(클라이언트) )
    -> 서버에서는 이제 브라우저에 '렌더링 된 html을 응답 함.'
        -> 아직 동적인 동작을 못함(동적인 동작은 js가 하는거임)
        -> 이시점에서는 상호작용이 불가한 상태

    ✅화면에 렌더링 = 曰: 화면에 렌더링
    - 🚨HTML 코드를 브라우저가 화면에 그려내는 작업
    (브라우저 -> 사용자)
        (브라우저가 서버로부터 받은 html 코드 = 즉 실제 컨텐츠를 화면에 그려내는 작업)
=> 단 이 두가지 작업은 화면은 보여지지만 '동작 기능'은 실행되지 않는다.
    (브라우저는 HTML 파일 하나만 받은 상태이다.)

🔽🔽이어서 웹 페이지 상호작용🔽🔽`

✅핵심1. JS Bundle(React app을 하나의 js 파일로 묶음, 렌더링 된 html에 다가 JS를 넣어 동적인 상태로 만들어줌)
- 이 서비스에서 접근 가능한 모든 컴포넌트 코드 존재(리액트 앱 : 모든 페이에 필요한 컴포넌트가 다 포함)
- 이제 웹 페이지의 상호작용까지 동작하도록 만들어 줘야 되기 때문에
Next 서버가 곧 바로 브라우저에게 후속으로 우리가 작성한
모든 자바스크립트 코드 그러니까 리액트 앱을 번들링해서 브라우저에게 보내줌.( 🚨FCP는 인터렉션이 불가능한 상태이고, JS BUNDLE은 가능한 상태)
- 사실상 React App
- 요약: 이제 브라우저(=클라이언트)는 서버로부터 받은 js 코드
        즉, 리액트 app을 직접 실행하여 현재 화면에 연결되어 있는 HTML 요소들과 연결을 시켜준다.
+[차이점]
🔷페이지 라우터: JS Bundle로 한꺼번에 다 묶은 다음에 브라우저로 전달한다.(JS Bundle 용량이 커져 하이드레이션이 적용하는 시간이 길어져 TTI까지 걸리는 길어짐)
🔷🚨앱 라우터 : 브라우저에서 하이드레이션 될 필요 없는(=상호작용이 없는) 컴포넌트들은 적용 안함.(용량이 줄어져 하이드레이션이 적용하는 시간이 줄고, TTI까지 걸리는 시간도 줄어듬)
- 서버 컴포넌트  : 서버측에서 사전 렌더링 진행할 때 딱 한번만 실행됨.
- 💡🚨클라이언트 컴포넌트 : 서버 컴포넌트 외 all -> js bundle 에 포함 -> 수화(브라우저) -> 상호작용 가능(유저)
                     사전 렌더링 진행 시 한번, 하이드레이션 진행 시 한번(총 2번 실행)
   => 브라우저가 JS Bundle을 불러오는 시간이 길어지면 하이드레이션을 지행하는 시간도 늘어나 버리기에
                TTI까지 늦어져 버리게된다는 문제점이 있다.



✅핵심2. 인터렉션(=상호작용)
- 자바스크립트 영역
- 🚨수화(Hydration, 하이드레이션) : HTML + JS 코드
- 자바크스립트 코드가 = 물
- 물을 뿌려주는 작업
ㄴ 웹 페이지가 상호작용까지 가능해진 상태


✅순서3. TTI (Time to Interactive)
- 하이드레이션(=상호작용이 가능해진 상태)이 적용되는 시간
ㄴ 💥리액트 app 을 직접 실행하여 현재 화면에 연결되어 있는 HTML 요소들과 연결을 소요시간
- Q.3s 걸린다( A. 요청이 들어온 시간부터 하이드레이션이 종료되는 과정까지 3초 시간이 걸렸다.)

✅💡사전 렌더링(Pre-rendering)
- Next의 핵심적인 기능
- 요약: 브라우저(클라이언트)의 요청에 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식
- 계기: 사전 렌더링을 통해 기존의 리액트의 단점이었던 FCP(페이지 접속 속도)를 빠르게 개선할 수 있다.
+ 동시에 그 이후 발생하는 페이지 이동들은 기존에 CSR 방식 그대로 사용.
( 빠른 FCP 달성 = React App의 단점 해소 + 빠른 페이지 이동=React App의 정점 승계)
이후 페이지이동은 CSR이랑 같다.
페이지 이동 흐름 : TTI(유저) -> 페이지 이동 요청 : 브라우저(JS실행(컴포넌트 교체)) -> 페이지 교체(유저에게 응답)

React App의 단점 해소
빠른 FCP 달성
 +
React App의 장점 승계
빠른 페이지 이동
