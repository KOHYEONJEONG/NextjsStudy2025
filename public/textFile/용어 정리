Nextjs

✅React의 CSR(Client Side Rendering)
- 장점 : 초기 접속 이후의 페이지 이동이 빠름
- 🚨단점: FCP(초기 접속 속도) 느림(브라우저가 하는일이 많아서)

✅FCP(First Contentful Paint)
- 브라우저가 처음으로 "콘텐츠"를 화면에 렌더링한 시점까지 걸린 시간
- 요청시작 시점으로부터 컨텐츠가 화면에 처음 나타나는데 걸리는 시간( 요청시작 <--> 컨텐츠 렌더링 )
 "콘텐츠"는 텍스트, 이미지(SVG 포함), 캔버스, 비디오 등 사용자가 실제로 볼 수 있는 요소를 의미해.

🔽🔽🔽🔽🔽🔽🔽🔽🔽🔽🔽
💡Nextjs 사용하면
💡FCP(초기 접속 속도) 속도 느린 부분이 낮아짐.
차이점: 사전에 렌더링된 html을 브라우저에 보낸다. 그대로 화면에 브라우저가 렌더링하고 사용자가 바로 완성된 화면을 볼 수 있다.


렌더링 헷갈리지?
    ✅JS 실행(렌더링) = 컴포넌트 렌더링
    - 🚨자바스크립트 코드(React 컴포넌트)를 HTML 페이지로 다 렌더링 시켜줌
        (리액트 컴포넌트들을 HTML로 변환하는 과정)
    (웹 서버와 브라우저 사이)
    -> 서버에서는 이제 브라우저에 '렌더링 된 html을 응답함.'
        -> 아직 동적인 동작을 못함(동적인 동작은 js가 하는거임)
        -> 이시점에서는 상호작용이 불가한 상태


    ✅화면에 렌더링
    - 🚨HTML 코드를 브라우저가 화면에 그려내는 작업
        (브라우저가 서버로부터 받은 html 코드 = 즉 실제 컨텐츠를 화면에 그려내는 작업)
    (브라우저와 사용자 사이)


✅핵심1. JS Bundle(렌더링 된 html에 다가 JS를 넣어 동적인 상태로 만들어줌)
- 이제 웹 페이지의 상호작용까지 동작하도록 만들어 줘야 되기 때문에 Next 서버가
곧 바로 브라우저에게 후속으로 우리가 작성한 모든 자바스크립트 코드 그러니까 리액트 앱을 번들링해서 브라우저에게 보내줌.
- 사실상 React App
- 요약: 이제 브라우저(=클라이언트)는 서버로부터 받은 js 코드
        즉, 리액트 app을 직접 실행하여 현재 화면에 연결되어 있는 HTML 요소들과 연결을 시켜준다.
+[차이점]
🔷페이지 라우터: JS Bundle로 한꺼번에 다 묶은 다음에 브라우저로 전달한다.(JS Bundle 용량이 커져 하이드레이션이 적용하는 시간이 길어져 TTI까지 걸리는 길어짐)
🔷🚨앱 라우터 : 브라우저에서 하이드레이션 될 필요 없는(=상호작용이 없는) 컴포넌트들은 적용 안함.(용량이 줄어져 하이드레이션이 적용하는 시간이 줄고, TTI까지 걸리는 시간도 줄어듬)
- 서버 컴포넌트  : 서버측에서 사전 렌더링 진행할 때 딱 한번만 실행됨.
- 💡🚨클라이언트 컴포넌트 : 서버 컴포넌트 외 all -> js bundle 에 포함 -> 수화(브라우저) -> 상호작용 가능(유저)
                     사전 렌더링 진행 시 한번, 하이드레이션 진행 시 한번(총 2번 실행)
   => 브라우저가 JS Bundle을 불러오는 시간이 길어지면 하이드레이션을 지행하는 시간도 늘어나 버리기에
                TTI까지 늦어져 버리게된다는 문제점이 있다.



✅핵심2. 인터렉션(=상호작용)
- 자바스크립트 영역
- 수화(Hydration, 하이드레이션) : HTML + JS 코드
- 자바크스립트 코드가 = 물
- 물을 뿌려주는 작업
ㄴ 웹 페이지가 상호작용까지 가능해진 상태


✅순서3. TTI (Time to Interactive)
- 하이드레이션(=상호작용이 가능해진 상태)이 적용되는 시간
ㄴ 💥리액트 app 을 직접 실행하여 현재 화면에 연결되어 있는 HTML 요소들과 연결을 소요시간
- Q.3s 걸린다( A. 요청이 들어온 시간부터 하이드레이션이 종료되는 과정까지 3초 시간이 걸렸다.)

✅💡사전 렌더링(Pre-rendering)
- Next의 핵심적인 기능
- 요약: 브라우저의 요청에 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식
- 사전 렌더링을 통해 기존의 리액트의 단점이었던 FCP를 빠르게 개선할 수 있다.
+ 동시에 그 이후 발생하는 페이지 이동들은 기존에 CSR 방식 그대로 사용.
( 빠른 FCP 달성=React App의 단점 해소 + 빠른 페이지 이동=React App의 정점 승계)

🔽🔽🔽
이후 페이지이동은 CSR이랑 같다.

TTI(유저) -> 페이지 이동 요청 : 브라우저(JS실행(컴포넌트 교체)) -> 페이지 교체(유저 응답)



React App의 단점 해소
빠른 FCP 달성
 +
React App의 장점 승계
빠른 페이지 이동
