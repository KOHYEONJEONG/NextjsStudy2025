⛔주의사항
1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다.(ex useEffect)
--------------------------------------------------------------------------
2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다.(use client 지시자 상단에 표기하면 됨.)
ㄴ 서버 컴포넌트 : 서버측에서만 실행되는 컴포넌트
ㄴ 클라이언트 컴포넌트 : 클라이언트에서만 실행되는 컴포넌트??? NOPE
ㄴㄴ 일반적인 컴포넌트이며
ㄴㄴ 1. 사전 렌더링을 위한 서버에서 1번 실행
ㄴㄴ 2. 하이드레이션을 위해 브라우저에서 1번 실행
= 서버와 클라이언트에서 모두 실행됨.
--------------------------------------------------------------------------
3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import 할 수 없다.
ㄴ 참조 : 주의사항-3번 이미지.png
ㄴ 클라이언트 컴포넌트는 브라우저에서 하이드레이션을 위해서 한 번 더 실행하게 되는데 이때 서버 컴포넌트는 존재하지 않으므로 오류 발생.
ㄴ 🚨오류발생(굉장히 많이 발생됨.)
ㄴㄴ 🚨하지만 Nextjs에서 알아서 서버 컴포넌트를 클라이언트 컴포넌트로 변경해줌 오류 방지(그닥 좋은 상황 아님)
ㄴㄴ 이런 클라이언트 컴포넌트에서 서버컴포넌트를 렌더링 하는 방식은 최대한 피하는게 맞다.

다만, 클라이언트 컴포넌트에서 자식으로 서버 컴포넌트를 둬야한다면 아래처럼 children props로 받아서 렌더링 시켜주는 방법을 사용하자.
import styles from "./page.module.css";
import ClientComponent from "../components/clientComponent";
import ServerComponent from "../components/serverComponent";

export default function Home() {
  //console.log("Home 컴포넌트 실행"); //서버에서만 실행(브라우저 콘솔창에는 한 번만 뜸, 서버 콘솔창만 여러번 뜸.)

  return (
    <div className={styles.page}>
      인덱스 페이지
      <ClientComponent>
        {/* children으로 이렇게 서버 컴포넌트로 넘겨주는 구조로 변경 시
         Nextjs는 서버 컴포넌트를 클라이언트 컴포넌트로 변경하지 않는다. */}
        <ServerComponent />
      </ClientComponent>
    </div>
  );
}

export default function ClientComponent({ children }: { children: ReactNode }) {
  //이 클라이언트 컴포넌트는 이 서버 컴포넌트를 직접 실행할 필요 없이 그냥 오직
  //서버 컴포넌트의 결과물만 딱 children이라는 props로 전달받도록 구조가 변경되기 때문이다.(먼저 보고오기 : with-searchbar)\page.tsx)
  // ⭐props로 받아서 렌더링만 하면 되기에!
  console.log("클라이언트 컴포넌트!");

  return <div>{children}</div>; //children 렌더링
}

--------------------------------------------------------------------------
4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 Props는 전달 불가하다.
직렬화(Serialization)
- 객체, 배열, 클래스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해 
아주 단순한 형태(문자열, Byte)로 변환하는 것...

[Before]
const person ={
    name : "kokoko",
    age: 29
}

[After]
{"name":"kokoko", age:29}

🚨단, 자바스크립트의 함수는 직렬화가 불가능하다.
ㄴ 서버 컴포넌트에서 클라이언트 컴포넌트로 향하는 Props가 될 수 없다는 뜻.
ㄴㄴ 서버 컴포넌트 ---> 클라이언트 컴포넌트 가 이러한 계층 구조를 지니는데 props로 서버 컴포넌트를 전달하지 못한다.
(사전렌더링 실행 시점 순서를 이해하면 이해가 쉬움)
사전 렌더링 시점때 서버와 클라이언트 컴포넌트가 동시에 실행되는게 아닌
서버 컴포넌트가 먼저 실행되고(이걸 RSC Payload라고 부름:JSON과 비슷한 형태의 문자열이 생성된다는 점) 클라이언트 컴포넌트가 실행되는 것이다.

서버컴포넌트 실행
ㄴ 브라우저로부터 접속 요청을 받아 사전 렌더링을 진행할 때 이때 클라이언트 컴포넌트와 함께 실행된다.
ㄴ 페이지를 구성하는 모든 컴포넌트들로 완성된 HTML 페이지를 생성하게 된다.